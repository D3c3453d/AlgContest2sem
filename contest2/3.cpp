/*
Даны неотрицательные целые числа n, k и массив целых чисел из диапазона [0..10^9] размера n.
Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k ∈[0..n-1] в отсортированном массиве.
Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n).
Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент.
Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j. Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

Пример
Ввод:
10 4
1 2 3 4 5 6 7 8 9 10

Вывод:
5

*/

#include <iostream>
#include <utility>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
#include <stack>

using namespace std;

void qSort(vector<int>::iterator L, vector<int>::iterator R,const vector<int>::iterator& median ){
    if (R-L<=1)return;
    auto x= L, y = L;
    int pivot= *(L + (R - L)/2);
    for (auto i = L;i!=R;++i){
        if (*i == pivot){
            swap(*i, *y);
            ++y;
        }
        if (*i < pivot){
            swap(*x, *i);
            if (x!= y)swap(*i, *y);
            x++, y++;
        }
    }
    if (median >= x && median < y){
        return;
    }
    if (median < x)qSort(L, x, median);
    if (median >= y)qSort(y, R, median);
}


void findK(vector<int>& nums, int k) {
    int n = nums.size();
    auto median = nums.begin() + k;
    qSort(nums.begin(), nums.end(), median);
    cout << *median;
}

int main(){
    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)cin >> arr[i];
    findK(arr, k);
}



